<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Розширений курс JS</title>
        <!-- <link rel="icon" type="image/x-icon" href="/images/favicon.ico"> тут іконка вкладки -->
    </head>
    <body>
        <div class="accordion accordion-flush" id="accordionFlushExample">
            <h1 class="tit_text_learn">Поглибленний курс JS</h1>
            <!-- Prototype -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingOne">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseOne" aria-expanded="false" aria-controls="flush-collapseOne">
                        <p class="header_name_item_stl">Щот таке Prototype</p>
                    </button>
                </h2>
                <div id="flush-collapseOne" class="accordion-collapse collapse" aria-labelledby="flush-headingOne" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Prototype</p>
                        <p>Прототип, це той самий об'єкт який присутній у батькіських елементів</p>
                        <p>Приклад додавання прототипу до глобального класу <code>Object</code>:</p>
                        <p><code>const person = new Object({ <br> &nbsp name: 'Boris',<br> &nbsp age: 30,<br> &nbsp languages: ['UA','EN','RU'],<br> &nbsp greet(){ <br>&nbsp &nbsp console.log(`Hellow world`);<br>&nbsp }<br>})<br>Object.prototype.sayHi = function () {<br>&nbsp console.log('HI')<br>}<br>person.sayHi();</code></p>
                        <p>В даному випадку було додано метод до прототипу глобального класу <code>Object</code> з назвою <code>sayHi()</code>, яку маємо змогу використовувати до будь-якого об'єкту</p>
                    </article>
                </div>
            </div>
            <!-- Контекст this -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingTwo">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwo" aria-expanded="false" aria-controls="flush-collapseTwo">
                        <p class="header_name_item_stl">Контекст this</p>
                    </button>
                </h2>
                <div id="flush-collapseTwo" class="accordion-collapse collapse" aria-labelledby="flush-headingTwo" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">this</p>
                        <p>Ключове слово <code>this</code> вказує завжди на об'єкт в контексті якого воно було викликано</p>
                        <p>Приклад використання контексту <code>this</code>:</p>
                        <p><code>function hello() {<br>&nbsp console.log('hellow world', this) <br>}<br>let person = {<br>&nbsp name: 'Boris',<br>&nbsp age: 30,<br>&nbsp sayHellow: hello<br>}<br> hello() <code class="comment_code">// В даному випадку контекст <code>this</code> буде вказувати на глобальний об'єкт <code>window</code></code><br>person.sayHellow() <code class="comment_code"> // В даному випадку контекст <code>this</code> буде вказувати на об'єкт <code>person</code></code></code></p>
                        <p class="sec_tit_txt_acord">метод bind</p>
                        <p>Для передачі контесту до іншого об'єкту використовується метод <code>bind</code>(Повертає нову функцію!!!), приклад:</p>
                        <p><code>function hello() {<br>&nbsp console.log('hellow world', this) <br>}<br>let person = {<br>&nbsp name: 'Boris',<br>&nbsp age: 30,<br>&nbsp sayHellow: hello,<br>&nbsp;&nbsp;sayHellowWindow: hello.bind(Window) <code class="comment_code"> // В даному випадку в функції <code>sayHellowWindow</code> буди виконуватись контекст this функції <code>hello</code> до об'єкту <code>window</code></code><br>}</code></p>
                        <p class="sec_tit_txt_acord">Пратичне використання методу bind</p>
                        <p><code>let person = {<br>&nbsp name: 'Boris',<br>&nbsp age: 30,<br>&nbsp; logInfo: function(){ <br> &nbsp &nbsp console.log(`Name is ${this.name}, age ${this.age}`); <br> &nbsp} &nbsp <br>}<br> let lena = {<br>&nbsp name: 'Lena',<br>&nbsp age: 25,<br>}<br>person.logInfo.bind(lena)()</code></p>
                        <p>В даному прикладі фукція об'єкту <code>person</code> logInfo буде виконана з контекстом об'єкту <code>lena</code></p>
                        <p class="sec_tit_txt_acord">метод call</p>
                        <p>Даний метод схожий на метод <code>bind</code>, але відмінність в тому, що після методу <code>bind</code> необхідно викликати функцію, а метод <code>call</code> викликає функцію автоматично!</p>
                        <p>Приклад використання методу <code>call</code>:</p>
                        <p><code>person.logInfo.call(lena)</code></p>
                        <p>В даному випадку приймається контекст об'єкту <code>lena</code> при цьому автоматично викликає функцію <code>logInfo</code></p>
                        <p class="sec_tit_txt_acord">метод apply</p>
                        <p>Приклад використання методу <code>apply</code>:</p>
                        <p><code>person.logInfo.apply(lena, [тут масив аргументів які попадають в дану функцію])</code> Після чого одразу викликається дана функція.</p>
                        <p class="sec_tit_txt_acord">Практичне використання прототипів і контексту</p>
                        <p>Задача: написати функцію, за допомогою якої можна помножити кожне число масиву <code>array = [1,2,3,4,5,6]</code> на те число яке буде передаватись в функцію</p>
                        <p><code>Array.prototype.multNumber = function (number){<br>&nbsp return this.map(i => i * number )<br>}<br>let array = [1,2,3,4,5,6]<br>console.log(array.multNumber(5));</code></p>
                        <p>В даному випадку ми створюємо прототип для глобального об'єкту <code>Array</code> де зазначаємо функцію, яка в себе сприймає змінну(число), на яке буде множитись кожен елемент масиву, після чого ця функція за допомогою метожу <code>map</code> сформує новий масив, до якого використовується контекст <code>this</code> який містить callback функцію де кожен елемент множиться на задане число. Таким чином створений метод <code>multNumber</code> прототипу глобального об'єкту <code>Array</code> можна буде застосовувати до люмого з масивів</p>
                    </article>
                </div>
            </div>
            <!-- Замикання -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingThree">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseThree" aria-expanded="false" aria-controls="flush-collapseThree">
                        <p class="header_name_item_stl">Замикання</p>
                    </button>
                </h2>
                <div id="flush-collapseThree" class="accordion-collapse collapse" aria-labelledby="flush-headingThree" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Замикання це функція в середині іншої функції</p>
                        <p class="sec_tit_txt_acord">Приклади використання замикання</p>
                        <ul>
                            <li class="list_style_accord">
                                <p><code>function calcFunction(n) <code class="comment_code"> // В даному випадку функція нам повертає нову функцію</code> { <br>&nbsp return function () {<br>&nbsp&nbsp console.log(1000*n); <br>&nbsp}<br>}<br>const result = calcFunction(5) <code class="comment_code"> // Так як функція повертає нам нову функцію то необхідно призначити їй змінну</code><br>result() <code class="comment_code"> // Так як цій змінній призначена функція достатньо її викликати</code></code></p>
                            </li>
                            <li class="list_style_accord">
                                <p><code>function calcNumbers(n) {<br>&nbsp return function (num) {<br>&nbsp &nbsp return n * num<br>&nbsp}<br>}<br>let staticNumberOne = calcNumbers(1) <code class="comment_code"> // В даному випадку замикає значення функції, та присвоюємо їй змінну</code><br>console.log(staticNumberOne(10)) <code class="comment_code"> // Викликаємо змінну із значенням яке необхідне для внутрішньої функції</code><br></code></p>
                            </li>
                            <li class="list_style_accord">
                                <p><code>function urlGenerator(domain) {<br>&nbsp return function (link) {<br>&nbsp &nbsp return `https://${link}.${domain}`<br>&nbsp}<br>}<br>let uaUrl = urlGenerator('ua')<br>console.log(uaUrl('sitename'))</code></p>
                            </li>
                        </ul>
                        <p class="sec_tit_txt_acord">Практичне завдання:</p>
                        <p>Умова: необхідно написати свою bind функцію, для цього є код до якого необхідно дописати функцію:</p>
                        <p><code>function logPerson (){<br>&nbsp console.log(`Person: ${this.name}, age: ${this.age},job: ${this.job}`)<br>}<br>let person1 = {<br>&nbsp name: 'Boris',<br>&nbsp age: 30,<br>&nbsp job: 'Front-end',<br>}<br>let person2 = {<br>&nbsp name: 'Oleg',<br>&nbsp age: 25,<br>&nbsp job: 'SMM'<br>}<br>bindFn(person1, logPerson)()<br>bindFn(person2, logPerson)()<br></code></p>
                        <p>Рішення:</p>
                        <p><code>function bindFn(context, fn){ <code class="comment_code">// В даному випадку <code>context</code> буде приймати об'єкт, <code>fn</code> приймає функцію для виводу інформації</code><br>&nbsp return function (...args){ <code class="comment_code">// Приймає значення всіх параметрів у вигляді масиву</code><br>&nbsp &nbsp fn.apply(context, args)<br>&nbsp}<br>}</code></p>
                    </article>
                </div>
            </div>
            <!-- Ассинхронність / Event Loop -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingFour">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseFour" aria-expanded="false" aria-controls="flush-collapseFour">
                        <p class="header_name_item_stl">Асинхронність</p>
                    </button>
                </h2>
                <div id="flush-collapseFour" class="accordion-collapse collapse" aria-labelledby="flush-headingFour" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Всі асинхронні функції попадають в <code>Web Apis</code> потім в <code>Callback Queue (черга) </code> після чого лише в <code>Call Stack</code>. Таким чином спочатку виконуються СИНХРОННІ, потім  АСИНХРОННІ функції. Навіть якщо в асинхронній функції на прикладі <code>setTimeOut(function(){<br>},0)</code> всеодно буде попадати в <code>Call Stack</code> після виконання СИНХРОННИХ функцій.</p>
                        <p>Таким чином АСИНХРОННІ функції спочатку попадають в чергу , потім за допомогою<code>Event LOOP</code> черга обробляється і переходить до виконання</p>
                    </article>
                </div>
            </div>
            <!-- Проміси (Promise) -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingFive">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseFive" aria-expanded="false" aria-controls="flush-collapseFive">
                        <p class="header_name_item_stl">Проміси (Promise)</p>
                    </button>
                </h2>
                <div id="flush-collapseFive" class="accordion-collapse collapse" aria-labelledby="flush-headingFive" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Promise - використовуються для асинхронного коду, для уникання вкладенності , та спрощенням роботи з ними</p>
                        <p>Приклад асинхронного коду, з декількома вложенностями:</p>
                        <p><code>setTimeout(() => {<br>&nbsp console.log('Preparing data...');<br>&nbsp let backEndData = {<br>&nbsp&nbsp server: 'ABS',<br>&nbsp&nbsp port: 5000,<br>&nbsp&nbsp status:'online'<br>&nbsp }<br>&nbsp setTimeout(()=>{<br>&nbsp&nbsp console.log('Server ready for working, data: ', backEndData);<br>&nbsp&nbsp },2000)<br>},2000)</code></p>
                        <p>Використання <code>Promise</code>, з декількома вложенностями:</p>
                        <p><code>const promise = new Promise ((resolve, reject)=>{<code class="comment_code"> // Проміс приймає в себе 2 параметри: resolve - використовується якщо функція успішна, reject - завершена з помилкою </code><br>&nbsp setTimeout(() => {<br>&nbsp &nbsp console.log('Preparing data...');<br>&nbsp &nbsp let backEndData = {<br>&nbsp &nbsp &nbsp server: 'ABS',<br>&nbsp &nbsp &nbsp port: 5000,<br>&nbsp &nbsp &nbsp status:'online'<br>&nbsp &nbsp }<br>&nbsp &nbsp resolve(backEndData) <code class="comment_code"> // Сюди необхідно передавати той результат який буде використовуватись в подальшому, в даному випадку об'єкт backEndData </code><br>&nbsp },2000)<br>}).then((data)=> {<code class="comment_code">// Data виступає в даному випадку як звийчайний параметр, це і буде наш об'єкт який отримали раніше з попереднього промісу "backEndData"</code><br>&nbsp return new Promise ((resolve,reject)=>{ <code class="comment_code"> // Можна вертати значення не нового промісу, а просто редагованого параметру "data"</code><br>&nbsp &nbsp data.modified = true <code class="comment_code">// Додаємо ключ з значенням в наш об'єкт</code><br>&nbsp &nbsp resolve(data)<br>&nbsp })<br>}).then(clientData => {<code class="comment_code"> // Можемо використати знову метод "then" так як попередньо повертаємо новий проміс використовуючи "new Promise"</code><br>&nbsp console.log('Server ready for working, data: ', clientData);<br>})</code></p>
                        <p class="sec_tit_txt_acord">Методи Promise</p>
                        <ul>
                            <li class="list_style_accord"><code>then()</code> коли виконається проміс відповідно до якого використовуємо цей метод то виконувати потрібно наступне. Буде виконаний після того як буде завершена асинхронна операція та буде в ній викликаний метод <code>resolve</code></li>
                            <li class="list_style_accord"><code>catch()</code> відслідковує помилку в промісі та викликається якщо використовується функція промісу <code>reject</code>. Приклад використання: <code>catch(err => console.error('Error: ',err))</code></li>
                            <li class="list_style_accord"><code>finally()</code> даний метод буде виклткано в любому випадку , незалежно чи була помилка</li>
                        </ul>
                        <p class="sec_tit_txt_acord">Методи глобального класу Promise</p>
                        <ul>
                            <li class="list_style_accord"><code>Promise.all([promice2,promise2, і так далі])</code> приймає в себе масив промісів, який вертає також проміс. Даний проміс який повертається в методі <code>all</code> буде виконаний лише тоді коли завершаться всі проміси в масиві. Приклад: <br> <code>Promise.all([promis1,promis2]).then(()=>{<br> &nbsp Тут певний код який буде виконано по завершенню всіх промісів в масиві <br>})</code></li>
                            <li class="list_style_accord"><code>Promise.race([promice2,promise2, і так далі])</code> приймає в себе масив промісів, який вертає також проміс. Даний проміс який повертається в методі <code>race</code> буде виконаний лише тоді коли завершиться найшвидший проміс в масиві. Приклад: <br> <code>Promise.race([promis1,promis2]).then(()=>{<br> &nbsp Тут певний код який буде виконано по завершенню найшвидчого промісу в масиві <br>})</code></li>
                        </ul>
                    </article>
                </div>
            </div>
            <!-- Об'єкти з Object.create -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingSix">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseSix" aria-expanded="false" aria-controls="flush-collapseSix">
                        <p class="header_name_item_stl">Об'єкти ( Object.create )</p>
                    </button>
                </h2>
                <div id="flush-collapseSix" class="accordion-collapse collapse" aria-labelledby="flush-headingSix" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p><code>Object.create({proto},{propertiesObject})</code> - створює новий об'єкт з вказаним прототипом і властивостями. Приймає в себе 2 параметри: <br> Об'єкт <code>{proto}</code> - приймає в себе прототипи (створюємо тут прототипи), який створюється та викликається в об'єкту звичайним шляхом, працює контекст this так як знаходиться в об'єкті. <br> Об'єкт <code>{propertiesObject}</code> приймає в себе значення об'єкту</p>
                        <p>Приклад створення об'єкту:</p>
                        <p><code>let person = Object.create(<br>&nbsp{<code class="comment_code">// Тут створюємо прототип</code><br> &nbsp &nbsp calculate(number){<br>&nbsp &nbsp &nbsp console.log('HELLO');<br>&nbsp &nbsp}<br>&nbsp},<br>&nbsp{<code class="comment_code"> // Тут поля об'єкту </code><br>&nbsp &nbsp name: {<code class="comment_code">// Дане поле має назву та являється також об'єктом</code><br>&nbsp &nbsp &nbsp value: 'Boris' <code class="comment_code"> // Значення поля name</code><br>&nbsp &nbsp &nbsp}<br>&nbsp}<br>)</code></p>
                        <p>В даному об'єкті неможливо пройтись циклом, так як у кожного з полів об'єкту є свої <code>PropertyDescription</code> тобто властивості які керують даним полем</p>
                        <p></p>
                        <p class="sec_tit_txt_acord">PropertyDescription полів об'єкту</p>
                        <ul>
                            <li class="list_style_accord"><code>enumerable</code> використовується для відображення поля об'єкту в циклі. Приймає значення лише <code>true/false</code>,за замовчуванням стоїть значення <code>false</code></li>
                            <li class="list_style_accord"><code>writable</code> надає змогу зміни поля об'єкту. Приймає значення лише <code>true/false</code>,за замовчуванням стоїть значення <code>false</code></li>
                            <li class="list_style_accord"><code>configurable</code> надає змогу видалення поля об'єкту. Приймає значення лише <code>true/false</code>,за замовчуванням стоїть значення <code>false</code></li>
                        </ul>
                        <p>Приклад задання ДЕСКРИПТОРІВ:</p>
                        <p><code>let person = Object.create({},<br>&nbsp {<br>&nbsp &nbsp name: {<br>&nbsp &nbsp &nbsp value: 'Boris',<br>&nbsp &nbsp &nbsp enumerable:true,<br>&nbsp &nbsp &nbsp writable: true,<br>&nbsp &nbsp &nbsp configurable: true<br>&nbsp &nbsp}<br>&nbsp}<br>)</code></p>
                        <p class="sec_tit_txt_acord">Getters/Setters об'єкту</p>
                        <p><code>get</code> - Функція що повертає значення</p>
                        <p><code>set</code> - Функція що задає значення</p>
                        <p>Приклад використання <code>get та set</code> на прикладі об'єкту в якому маючи поля будемо визначати для поля <code>age</code> вік:</p>
                        <p><code>let person = Object.create({},<br>&nbsp{<br>&nbsp &nbsp birthDay: { <br>&nbsp &nbsp &nbsp value: 1992<br>&nbsp &nbsp },<br>&nbsp &nbsp age: {<br>&nbsp &nbsp &nbsp get(){ <code class="comment_code"> // В двному випадку ми визначаємо значення person.age та повертаємо його.</code><br>&nbsp &nbsp &nbsp &nbsp return new Date().getFullYear() - this.birthDay <br>&nbsp &nbsp &nbsp},<br>&nbsp &nbsp &nbsp set(value){ <code class="comment_code">// Виконуємо заміну background при вказані значення для person.age . Можна писати будь яку дію</code> <br>&nbsp &nbsp &nbsp &nbsp document.body.style.background = value<br>&nbsp &nbsp &nbsp}<br>&nbsp &nbsp} <br>&nbsp}<br>)<br>person.age = 'red' <code class="comment_code">// Вказуємо який колір буде змінено</code> <br>console.log(person.age); <br></code></p>
                        <p class="sec_tit_txt_acord">Цикл forin</p>
                        <p>Для використання даного циклу до об'єкту без включення створених прототипів в нього необхідно використати певну перевірку в циклі:</p>
                        <p><code>for (let key in person){<br>&nbsp if(person.hasOwnProperty(key)){<br>&nbsp &nbsp console.log('KEY OBJECT:', key);<br>&nbsp}<br>}</code></p>
                        <p>Таким чином буде перевірка <code>person.hasOwnProperty(key)</code>, яка буде виконувати код лише для ключів та в циклі не буде враховуватись <code>Prototype</code>. <br> Дану перевірку необхідно роботи завжди коли використовується цикл <code>forin</code></p>
                    </article>
                </div>
            </div>
            <!-- Класи -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingSeven">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseSeven" aria-expanded="false" aria-controls="flush-collapseSeven">
                        <p class="header_name_item_stl">Класи ES6</p>
                    </button>
                </h2>
                <div id="flush-collapseSeven" class="accordion-collapse collapse" aria-labelledby="flush-headingSeven" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Всі класи називаються з великої літери (за конвенцією)</p>
                        <p>Приклад створення класу:</p>
                        <p><code>class Animal {<br>&nbsp constructor(options){<code class="comment_code"> // Створення класу, та через constructor приймаємо об'єкт options, який будемо передавати в даний клас</code><br> &nbsp &nbsp this.name = options.name, <code class="comment_code">// Ініціалізувати поля об'єкту необхідно через контекст this</code><br> &nbsp &nbsp this.age = options.age<br> &nbsp &nbsp this.tail = options.tail<br> &nbsp } <br> &nbsp voice() { <code class="comment_code"> // Присутня змога створювати методи які попадуть в прототип об'єкту</code> <br> &nbsp &nbsp console.log('I am animal')<br> &nbsp }<br>}<br>let dog = new Animal ({ <code class="comment_code"> // створення об'єкту за допомогою класу</code> <br> &nbsp name:'Lucky',<br> &nbsp age: 7,<br> &nbsp tail: true<br>})</code></p>
                        <p>В даному випадку отримаємо не просто об'єкт а наслідника від класу <code>Animal</code></p>
                        <p class="sec_tit_txt_acord">Наслідування класів</p>
                        <p> Приклад наслідування класів:</p>
                        <p><code>class Animal {<br>&nbsp constructor(options){<br> &nbsp &nbsp this.name = options.name,<br> &nbsp &nbsp this.age = options.age<br> &nbsp &nbsp this.tail = options.tail<br> &nbsp } <br> &nbsp voice() { <br> &nbsp &nbsp console.log('I am animal')<br> &nbsp }<br>}</code></p>
                        <p>Для наслідування іншим класом поточного необхідно використовувати наступний вид запису:</p>
                        <p><code>class typeAnimal extends Animal {<code class="comment_code"> // за допомогою слова extends вказуємо який клас ми наслідуємо </code> <br> &nbsp constructor(options){<br> &nbsp &nbsp super(options) <code class="comment_code"> // Підключення конструктора класу якого ми будемо наслідувати</code> <br> &nbsp &nbsp this.typeAnim = options.typeAnim <br> &nbsp } <br> &nbsp; voice() { <code class="comment_code"> // В даному випадку метод voice() поточного класу буде перезаписувати такий самий метод в батьківському класі</code> <br> &nbsp &nbsp console.log('I have type')<br> &nbsp } <br>}</code></p>
                        <p class="sec_tit_txt_acord">Використання геттерів/сеттерів (get / set) в класах</p>
                        <p><code>class typeAnimal extends Animal { <br> &nbsp constructor(options){<br> &nbsp &nbsp super(options) <br> &nbsp &nbsp this.typeAnim = options.typeAnim <br> &nbsp } <br> &nbsp; get() { <code class="comment_code"> // Створений геттер буде повертати нове поле в об'єкт з первним значенням співвідношення віку тварини до людини </code> <br> &nbsp &nbsp return this.humAge = this.age * 3<br> &nbsp } <br> &nbsp; set(value) { <code class="comment_code"> // Створений сеттер буде повертати нове значення віку в об'єкт </code> <br> &nbsp &nbsp this.age = value<br> &nbsp } <br>}</code></p>
                        <p class="sec_tit_txt_acord">Приклад використання класів</p>
                        <p><code>class Component {<br> &nbsp constructor(selector){ <code class="comment_code"> // Отримуємо селектор, та задаємо методи зміни display для даного селектору</code> <br> &nbsp &nbsp this.$el = document.querySelector(selector)<br> &nbsp }<br> &nbsp hide(){<br> &nbsp &nbsp this.$el.style.display = 'none'<br> &nbsp &nbsp}<br> &nbsp show(){<br> &nbsp &nbsp this.$el.style.display = 'block'<br>&nbsp &nbsp}<br>}<br>class Box extends Component {<br> &nbsp constructor(options){<br> &nbsp &nbsp super(options.selector) <code class="comment_code"> // Наслідуємо від класу Component конструктор з селектором, та додаємо свої опції до новго класу Box</code> <br> &nbsp &nbsp this.$el.style.width = this.$el.style.height = options.size + 'px' <code class="comment_code"> // Так як отримуємо число integer для отримання рядка додаємо 'px'</code> <br> &nbsp &nbsp this.$el.style.background = options.color <br> &nbsp &nbsp this.$el.style.borderRadius = options.radius <br> &nbsp }<br>}<br>let box1 = new Box ({<br> &nbsp selector: '.box1',<br> &nbsp size: 100,<br> &nbsp color:'red'<br>})<br>let box2 = new Box ({<br> &nbsp selector: '.box3',<br> &nbsp size: 50,<br> &nbsp color:'green',<br> &nbsp radius: '50%'<br>})<br>box1.show()<br>box2.show()</code></p>
                        <p>В результаті чого отримуємо код, завдяки якому викликаючи методи в створених елементів можемо керувати значенням <code>display: block/none</code></p>
                    </article>
                </div>
            </div>
            <!-- async / await  -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingEight">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEight" aria-expanded="false" aria-controls="flush-collapseEight">
                        <p class="header_name_item_stl">async, await та сервер fetch</p>
                    </button>
                </h2>
                <div id="flush-collapseEight" class="accordion-collapse collapse" aria-labelledby="flush-headingEight" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p><code>await</code> - працює лише з асинхронними функціями. Допомагає не переходити до наступної стрічки коду , поки не виконається проміс</p>
                        <p>Приклад використання <code>async, await</code>: </p>
                        <p><code>let delay = ms => { <code class="comment_code">// Створення функції для затримки</code> <br>&nbsp return new Promise(resolve => setTimeout(()=>resolve(),ms))<br>}<br>const url = 'https://jsonplaceholder.typicode.com/todos' <code class="comment_code">// посилання на fetch сервер</code><br>async function fetchAsyncTodos (){ <code class="comment_code">// async перед функцією перетворює її в асинхронну(для роботи з await)</code> <br> &nbsp console.log('Fetch todo started....'); <br> &nbsp try{ <code class="comment_code">// try / catch використовується для відслідкування коректної роботи коду. В try пишеться код</code><br> &nbsp &nbsp await delay(2000) <code class="comment_code">// await використовується для очікування поки обробиться promis в функції delay, після чого буде виконання подальшого коду</code><br> &nbsp &nbsp const responce = await fetch(url) <code class="comment_code">// метод fetch() повертає promis. Для його отримання призначаємо йому змінну</code><br> &nbsp &nbsp const data = await responce.json() <code class="comment_code">// використовуємо метод json в методі responce()</code><br> &nbsp &nbsp console.log('Data:', data);<br> &nbsp} catch(e) { <code class="comment_code">// Якщо код з методу try повертає помилку, то метод catch її відслідкує</code><br> &nbsp &nbsp console.error(e);<br> &nbsp} finally { <code class="comment_code">// в методі finally код буде виконаний в любому випадку, навіть якщо буде помилка в функції</code><br> &nbsp &nbsp console.log('End of fucntion');<br> &nbsp}<br>}<br>fetchAsyncTodos() <code class="comment_code"> // Дана функція також повертає promice</code></code></p>
                    </article>
                </div>
            </div>
            <!-- proxy, функції, об'єкти, класи -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingNine">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <p class="header_name_item_stl">Proxy. Об'єкти, функції, класи</p>
                    </button>
                </h2>
                <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Proxy в об'єктах</p>
                        <p>Proxy - певний клас в JS який допомагає створювати певні пастки для об'єктів,класів чи функцій</p>
                        <p>Методи Proxy які часто використовуються.</p>
                        <ul>
                            <li class="list_style_accord"><code>get()</code> - метод який буде повертати якесь значення</li>
                            <li class="list_style_accord"><code>set()</code> - метод для задавання значення</li>
                            <li class="list_style_accord"><code>has()</code> - метод для перевірки наявності в об'єкті поля, повертає значення true/false. Приклад використання в коді <code>'name' in objProxy</code></li>
                            <li class="list_style_accord"><code>deleteProperty()</code> - видалення певної властивості з об'єкту. Приклад використання в коді <code>delete objProxy.name</code></li>
                        </ul>
                        <p>Приклад використання класу Proxy для об'єктів:</p>
                        <p><code>let person = {<br> &nbsp name: 'Boris',<br> &nbsp age: 30,<br> &nbsp country: 'Ukrain'<br>}<br><br>const objProxy = new Proxy(person, { <code class="comment_code">// Створення proxy для об'єкту person, приймає в себе значення (target,{методи})</code> <br> &nbsp get(target,prop){ <code class="comment_code">// Огляд значення об'єкту</code> <br> &nbsp &nbsp return target[prop]<br> &nbsp},<br> &nbsp set(target,prop,value){ <code class="comment_code">// Задаємо значення полю об'єкта, якщо такого поля немає то буде видавати помилку</code> <br> &nbsp &nbsp if (prop in target){<br> &nbsp &nbsp &nbsp target[prop] = value<br> &nbsp &nbsp} else {<br> &nbsp &nbsp &nbsp throw new Error(`No ${prop} field in target`)<br> &nbsp &nbsp}<br> &nbsp},<br> &nbsp has(target,prop){ <code class="comment_code">// Перевірка навності поля в об'єкті</code> <br> &nbsp &nbsp return ['name','age','country'].includes(prop)<br> &nbsp },<br> &nbsp deleteProperty(target, prop){ <code class="comment_code">// Видалення певного поля в об'єкті</code> <br> &nbsp &nbsp delete target[prop]<br> &nbsp }<br>})<br>objProxy.year = 1992 <code class="comment_code">// Використання методу set(), в даному випадку буде помилка так як поля year в об'єкті немає</code> <br>console.log('name' in objProxy); <code class="comment_code">// Перевірка наявності поля name в об'єкті</code> <br>delete objProxy.name <code class="comment_code">// Видалення поля name в об'єкті</code></code></p>
                        <p class="sec_tit_txt_acord">Proxy в функціях</p>
                        <p>Приклад використання класу Proxy для функцій</p>
                        <p><code>let log = text => `Log: ${text}`<br>let funcProxy = new Proxy (log,{<br> &nbsp apply(target, thisArg, args){<br> &nbsp &nbsp console.log('Calling funcProxy....');<br> &nbsp &nbsp return target.apply(thisArg,args).toUpperCase()<br> &nbsp}<br>})<br>funcProxy()</code></p>
                        <p class="sec_tit_txt_acord">Proxy в класах</p>
                        <p>Приклад використання класу Proxy для класів</p>
                        <p><code>class Person {<br>&nbsp constructor(name, age){<br>&nbsp &nbsp this.name = name<br>&nbsp &nbsp this.age = age<br>&nbsp}<br>}<br>let PersonProxy = new Proxy(Person,{<br>&nbsp construct(target,args){<br>&nbsp &nbsp console.log('Construct.......');<br>&nbsp &nbsp return new target(...args)<br>&nbsp }<br>})<br>const p = new PersonProxy('Boris',30)</code></p>
                        <p class="sec_tit_txt_acord">Приклади практичного використання PROXY</p>
                        <p><code>Приклад по використанні на Wrapper(обкладинки)</code></p>
                        <p><code>const withDefaultValue = (target,defaultValue = 0) => {<br>&nbsp return new Proxy (target,{<br>&nbsp &nbsp get:(obj,prop) => (prop in obj) ? obj[prop] : defaultValue <br>&nbsp})<br>}<br>const position = withDefaultValue(<br>&nbsp{<br>&nbsp &nbsp x: 24,<br>&nbsp &nbsp y: 42<br>&nbsp},0<br>)</code></p>
                        <p>В даному випадку отримаємо проксі об'єкт з значеннями X та У</p>
                        <p><code>Приклад по використанні на Hidden properties(Приховані властивості)</code></p>
                        <p>Задача: Створення обгортки для об'єкту, яка буде приховувати певні властивості які самостійно вказуємо</p>
                        <p><code>const withHiddenProps = (target, prefix = '_') => {<br>&nbsp return new Proxy(target,{<br>&nbsp &nbsp has:(obj, prop)=> (prop in obj) && (!prop.startsWith(prefix)),<br>&nbsp &nbsp ownKeys:obj => Reflect.ownKeys(obj).filter(p => !p.startsWith(prefix)),<br>&nbsp &nbsp get:(obj,prop,receiver)=> (prop in receiver) ? obj[prop] : void 0<br>&nbsp})<br>}<br>const data = withHiddenProps({<br>&nbsp name: 'Boris',<br>&nbsp age: 30,<br>&nbsp _pass: '13325'<br>})<br>console.log(data.name);<br>console.log(data.age);<br>console.log(data._pass); <code class="comment_code">Таким чином доступу до даного поля не буде ні через ітерацію, ні через звернення напряму до нього. Воно приховане.</code><br></code></p>
                        <p><code>Приклад по використанні на Optimization(Оптимізація)</code></p>
                        <p>Задача: пошук елементу по ІD</p>
                        <p><code>const IndexedArray = new Proxy(Array, {<br>&nbsp construct(target, [args]){<br>&nbsp &nbsp const index = {}<br>&nbsp &nbsp args.forEach(item => (index[item.id] = item))<br>&nbsp &nbsp return new Proxy (new target(...args),{<br>&nbsp &nbsp &nbsp get(arr,prop){<br>&nbsp &nbsp &nbsp &nbsp switch (prop) {<br>&nbsp &nbsp &nbsp &nbsp &nbsp case 'push':<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp return item => {<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp index[item.id] = item<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp arr[prop].call(arr,item)<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp}<br>&nbsp &nbsp &nbsp &nbsp &nbsp case 'findById': <br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp return id => index[id]<br>&nbsp &nbsp &nbsp &nbsp &nbsp default:<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp return arr[prop];<br>&nbsp &nbsp &nbsp &nbsp}<br>&nbsp &nbsp &nbsp}<br>&nbsp &nbsp})<br>&nbsp}<br>})<br>const users = new IndexedArray([<br>&nbsp{id:1, name:'Boris', age:30, job:'Front-end'},<br>&nbsp{id:2, name:'Inna', age:24, job:'Nurce'},<br>&nbsp{id:3, name:'Igor', age:27, job:'Fullstack'},<br>&nbsp{id:4, name:'Sergey', age:31, job:'Back-end'}<br>])</code></p>
                        <p>Тепер присутній метод для використання <code>findById</code> який ми можемо використати для пошуку особи за ID. <code>users.findById(2)</code> після чого буде відображено об'єкт з користувачем який має ID 2</p>
                    </article>
                </div>
            </div>
            <!-- Генератори. Symbol iterator, for of -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingTen">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTen" aria-expanded="false" aria-controls="flush-collapseTen">
                        <p class="header_name_item_stl">Генератори. Symbol iterator, for of</p>
                    </button>
                </h2>
                <div id="flush-collapseTen" class="accordion-collapse collapse" aria-labelledby="flush-headingTen" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Генератори - це функції які помжуть послідовно видавати результати її роботи</p>
                        <p>Приклад генератору:</p>
                        <p><code>function* strGenerator(){ <code class="comment_code">// Символ * робить з функції генератор, обо'язково щоб воно стояло після слова function</code><br>&nbsp yield 'H'<code class="commnet _code">// Ключове слово yield - виконує послідовно дію</code><br>&nbsp yield 'e'<br>&nbsp yield 'l'<br>&nbsp yield 'l'<br>&nbsp yield 'o'<br>}<br>const str = strGenerator() <code class="comment_code">// Дана функція буде повертати об'єкт</code><br>str.next() <code class="comment_code">// Метод .next() викликає наступну дію в функції</code> <br></code></p>
                        <p class="sec_tit_txt_acord">Цикл for of</p>
                        <p>Даний цикл працює лише якщо в прототипі присутній <code>Symbol.iterator</code> . Всі генератори мають в собі цей прототип, що дозволяє використовувати для значень функції що повертає функція цикл <code>for of</code>, приклад:</p>
                        <p><code>function* iter(n=10){<br>&nbsp for(let i=0; i менше n; i++){<br>&nbsp &nbsp yield i<br>&nbsp}<br>}<br>for(let key of iter()){<br>&nbsp console.log(key);<br>}</code></p>
                    </article>
                </div>
            </div>
            <!-- Методи масисвів -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingEleven">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                        <p class="header_name_item_stl">Методи масивів</p>
                    </button>
                </h2>
                <div id="flush-collapseEleven" class="accordion-collapse collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p>Масив що буде використовуватись в методах: <br><code>let people = [<br>&nbsp{name:'Sergey',age:22 ,budeget:5000},<br>&nbsp{name:'Igor',age:17 ,budeget:3800},<br>&nbsp{name:'Boris',age:30 ,budeget:8000},<br>&nbsp{name:'Oleg',age:16 ,budeget:3000},<br>&nbsp{name:'Alex',age:27 ,budeget:7000}<br>]</code></p>
                        <p class="sec_tit_txt_acord">Цикл ForEach</p>
                        <p>Приклад використання циклу:</p>
                        <p><code>people.forEach(member => {<br>&nbsp console.log(member);<br>});</code></p>
                        <p class="sec_tit_txt_acord">Метод Map</p>
                        <p>Дайни метод працює схоже як цикл <code>forEach</code>. Після використання повертає новий масив! Обов'язково необхідно щоб даний метод повертав певне значення</p>
                        <p>Приклад використання :</p>
                        <p><code>let newArr = people.map(person => {<br>&nbsp return person<br>})</code></p>
                        <p class="sec_tit_txt_acord">Метод filter</p>
                        <p>Використовується для фільтрації масиву по певній умові. Повертає новий масив!</p>
                        <p>Приклад використання :</p>
                        <p><code>let adult = people.filter(person => person.age >= 18)</code></p>
                        <p>В даному випадку буде відфільтровано об'єкти масиву, та створено новий масив з людьми які старше 18 років</p>
                        <p class="sec_tit_txt_acord">Метод reduce</p>
                        <p>Даний метод повертає фінальне значення</p>
                        <p>Приклад використання :</p>
                        <p><code>let cashPeople = people.reduce((total,person) => total + person.budeget, 0)</code></p>
                        <p>В даному випадку метод <code>reduce(total,target)</code> приймає в себе 2 значення: total - початкове значення, target - елемент масиву. <code>0</code> в даному записі відповідає за початкове значення</p>
                        <p class="sec_tit_txt_acord">Метод find</p>
                        <p>Використовується для пошуку за певною умовою елементу</p>
                        <p>Приклад використання :</p>
                        <p><code>let boris = people.find(person => person.name === 'Boris')</code></p>
                        <p>Буде знайдено людино з масиву, ім'я якої відповідає заданому</p>
                        <p class="sec_tit_txt_acord">Метод findIndex</p>
                        <p>Використовується для пошуку за певною умовою індексу елемента масива</p>
                        <p>Приклад використання :</p>
                        <p><code>let borisIndex = people.findIndex(person => person.name === 'Boris')</code></p>
                        <p class="sec_tit_txt_acord">Приклад використання методів разом</p>
                        <p><code>let newArr = people.filter(person=>person.budeget > 3500).map(person => {<br>&nbsp return {<br>&nbsp &nbsp name: person.name,<br>&nbsp &nbsp age: person.age,<br>&nbsp &nbsp budget: person.budeget<br>&nbsp}<br>})<br>console.log('newArr: ', newArr);</code></p>
                        <p>В даному випадку відсортували всіх людей в яких бюджет більше 3500, після чого методом <code>map</code> повернули масив об'єктів з певними полями(таким чином можна змінювати елементи об'єктів) </p>
                    </article>
                </div>
            </div>
            <!-- Map Set WeakMap WeakSet -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingTwelve">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                        <p class="header_name_item_stl">Map , Set , WeakMap , WeakSet</p>
                    </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Методи утворення масива в об'єкт та навпаки</p>
                        <ul>
                            <li class="list_style_accord"><code>Object.entries(тут об'єкт)</code> - утворення з об'єкту масив. Для цього має бути масив записаний в наступному викляді(ключ, значення)<br><code>let entries = [<br>&nbsp['name', 'Boris'],<br>&nbsp['age', 26],<br>&nbsp['job','Front-end']<br>]</code></li>
                            <li class="list_style_accord"><code>Object.fromEntries(тут масив)</code> - утворення з масиву об'єкту</li>
                        </ul>
                        <p class="sec_tit_txt_acord">Map</p>
                        <p><code>Map</code> являється аналогом об'єкту, лише більш продвинутим приклад:</p>
                        <p><code>let map = new Map ([<br>&nbsp['name', 'Boris'],<br>&nbsp['age', 26],<br>&nbsp['job','Front-end']<br>])</code><br> Таким чином якщо переглянути через console.log(someMap) буде наступне відображення даному map: <code>Map(3) {'name' => 'Boris', 'age' => 26, 'job' => 'Front-end'}</code>. Тобто буде відображено ключ, якому належить певне значення</p>
                        <p>В ньому можна в якості ключів вказувати будь-який тип даний! </p>
                        <p><code>МЕТОДИ РОБОТИ З MAP:</code></p>
                        <ul>
                            <li class="list_style_accord"><code>get("name")</code> Отримати значення певного ключа</li>
                            <li class="list_style_accord"><code>set("country", 'Ukrain')</code> Додати значення для об'єкту. Після використання повертає об'єкт вже з цим значенням</li>
                            <li class="list_style_accord"><code>clear()</code> Повне очищення map</li>
                            <li class="list_style_accord"><code>has('age')</code> Перевірка чи наявний ключ в map, вкртає значення true/false</li>
                            <li class="list_style_accord"><code>delete('age')</code> Видалення ключа "а". Повертає boolean значення чи успішно чи ні видалено. Потрібно використовувати так щоб після, якщо виконується chain запис, не було методів більше</li>
                            <li class="list_style_accord"><code>size</code> Перевірка кількості елементів</li>
                            <li class="list_style_accord"><code>keys()</code> Прегляд ключів (ітератор)</li>
                            <li class="list_style_accord"><code>values()</code> Прегляд значень ключів (ітератор)</li>
                        </ul>
                        <p><code>Цикли якими можна ітерувати MAP:</code></p>
                        <ul>
                            <li class="list_style_accord"><code>forof</code> приклад:<br><code>for (let elem of map) {<br>&nbsp console.log(elem);<br>}</code><br>AБО такий тип, який буде виводити одразу не масиви, а ключ та значення:<br><code>for (let [key,value] of object) {<br>&nbsp console.log(key,value);<br>}</code><br>AБО такий тип, який буде виводити лише значення:<br><code>for (let val of map.values()) {<br>&nbsp console.log(val);<br>}</code><br>AБО такий тип, який буде виводити лише ключ:<br> <code>for (let keys of map.keys()) {<br>&nbsp console.log(keys);<br>}<br></code></li>
                            <li class="list_style_accord"><code>forEach</code> приклад:<br><code>map.forEach((val,key,m)=>{<br>&nbsp console.log(key,val);<br>})</code> - forEach приймає в себе 3 значення: <code>val</code> - значення ключа,<code>key</code> - назва ключа <code>m</code> - сам map по якому проходимся циклом</li>
                        </ul>
                        <p><code>Способи перетворення MAP в масив:</code></p>
                        <ul>
                            <li class="list_style_accord">Використовуючи оператор <code>spread</code>:<br><code>let newArr = [...map]</code><br> Таким чином буде сформовано масив зі значеннями цієї карти</li>
                            <li class="list_style_accord">Використовуючи <code>Array.from(map)</code>:<br><code>let newArr = Array.from(map)</code></li>
                        </ul>
                        <p><code>Способи перетворення MAP в звичайний об'єкт:</code></p>
                        <ul>
                            <li class="list_style_accord"><code>let mapObj = Object.fromEntries(map.entries())</code></li>
                        </ul>
                        <p><code>Приклад використання MAP</code></p>
                        <p>Задача: необхідно маючи користувачів організувати перегляд коли користувач відвідував сайт, або переглядав статтю.</p>
                        <p><code>let users = [<br>&nbsp{name:'Boris', country:'Ukrain'},<br>&nbsp{name:'Igor', country:'Poland'},<br>&nbsp{name:'Jon', country:'USA'}<br>]<br><br>let visits = new Map()<br>visits.set(users[0], new Date())<br>&nbsp .set(users[1], new Date(new Date().getTime() + 1000 *60))<br>&nbsp .set(users[2], new Date(new Date().getTime() + 5000 *60))<br><br>function lastVisits(user){<br>&nbsp return visits.get(user)<br>};<br>console.log(lastVisits(users[2]));</code></p>
                        <p class="sec_tit_txt_acord">set</p>
                        <p><code>Set</code> являється аналогом масиву, але має свої особливості, він не зберігає в собі дублікати, приклад створення:</p>
                        <p><code>let set = new Set([1,1,1,1,4,5,6,9])</code>. </p>
                        <p>Якщо переглянути даний масив через консоль буде відображено <code>Set {1,4,5,6,9}</code>. Тобто даний масив в собі не зберігає дублікати</p>
                        <p>Методи для роботи з <code>set</code>:</p>
                        <ul>
                            <li class="list_style_accord"><code>size</code> - Розмір сету</li>
                            <li class="list_style_accord"><code>add('3')</code> - Додавання елементу</li>
                            <li class="list_style_accord"><code>clear()</code> - Очищення сету</li>
                            <li class="list_style_accord"><code>delete(4)</code> - Видалення певного елементу</li>
                            <li class="list_style_accord"><code>has(4)</code> - Перегляд чи наявне значення в сеті. Повертає значення true/false</li>
                            <li class="list_style_accord"><code>keys()</code> - Перегляд елементів (ітератор)</li>
                            <li class="list_style_accord"><code>values()</code> - Перегляд елементів (ітератор)</li>
                        </ul>
                        <p><code>Приклад використання SET:</code></p>
                        <p>Задача: "Необхідно написати функцію , яка буде повертати унікальне значення з масиву"</p>
                        <p><code>function uniqValues (array){<br>&nbsp return [...new Set(array)]<br>}<br>console.log(uniqValues([1,1,1,1,1,1,1,6,6,3,8,9,9,9,9,9,]));</code><br><br> Або використати наступний варіант <br><br><code>function uniqValues (array){<br>&nbsp return Array.from(new Set(array))<br>}<br>console.log(uniqValues([1,1,1,1,1,1,1,6,6,3,8,9,9,9,9,9,]));</code></p>
                        <p>В даному випадку буде сформовано новий масив з значеннями які не дублюються</p>
                        <p class="sec_tit_txt_acord">WeakMap</p>
                        <p>По суті, те саме що і <code>map</code>. Різниця в тому, що даний тип допомагає уникати витоку інформації </p>
                        <p>В <code>WeakMap</code> Ключами можуть бути лише об'єкти!</p>
                        <p>Присутні наступні методи <code> get,set,delete,has</code></p>
                        <p class="sec_tit_txt_acord">WeakSet</p>
                        <p>По суті, те саме що і <code>WeakMap</code>. Значеннями даного сету можуть бути лише об'єкти </p>
                        <p>Присутні наступні методи <code>has</code></p>
                    </article>
                </div>
            </div>
            <!-- Запити на сервер Fetch, XMLHttpRequest, Ajax -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingTherteen">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTherteen" aria-expanded="false" aria-controls="flush-collapseTherteen">
                        <p class="header_name_item_stl">Запити на сервер Fetch, XMLHttpRequest, Ajax</p>
                    </button>
                </h2>
                <div id="flush-collapseTherteen" class="accordion-collapse collapse" aria-labelledby="flush-headingTherteen" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                    </article>
                </div>
            </div>
            <!-- <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingOne">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseOne" aria-expanded="false" aria-controls="flush-collapseOne">
                        <p class="header_name_item_stl">Щот таке Prototype</p>
                    </button>
                </h2>
                <div id="flush-collapseOne" class="accordion-collapse collapse" aria-labelledby="flush-headingOne" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Прототип, це той самий об'єкт який присутній у батькіських елементів</p>
                        <p>Приклад додавання прототипу до глобального класу <code>Object</code>:</p>
                        <p><code>const person = new Object({ <br> &nbsp name: 'Boris',<br> &nbsp age: 30,<br> &nbsp languages: ['UA','EN','RU'],<br> &nbsp greet(){ <br>&nbsp &nbsp console.log(`Hellow world`);<br>&nbsp }<br>})<br>Object.prototype.sayHi = function () {<br>&nbsp console.log('HI')<br>}<br>person.sayHi();</code></p>
                        <p>В даному випадку було додано метод до прототипу глобального класу <code>Object</code> з назвою <code>sayHi()</code>, яку маємо змогу використовувати до будь-якого об'єкту</p>
                    </article>
                </div>
            </div> -->


        </div>
    </body>
</html>